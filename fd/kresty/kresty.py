# данная программа делает наиболее разумный ход в игре крестики-нолики
# программа играет за крестики (X)
# импортирую библиотеку random, чтобы в будущем использовать random.choice, для выбора постановки крестика
import random

# создаю функцию, которая будет выполнять поставленную задачу
def krestikiNoliki():
    # чтобы программа вообще могла работать, надо определить в каком формате будут данные на вход
    # у меня клетки ограничены [], где символ внутри - это то, что есть в клетке (для обоззначения пустоты буду использовать пробел)
    # то есть пользователь вводит [X] или [0] или [ ]
    # последующий блок кода это ввод пользователем поля
    print ("Введите игровое поле, крестик - [X], нолик - [0], пустая поле - [ ]") # вывод сообщения для пользователя
    board = [] # создаю пустой список, в который програама будет добавлять строки
    for i in range (3): # цикл, который будет добавлять строки в список board
        line = input().strip() # ввод строки
        row = [kletki for kletki in line.replace('[', '').replace(']', '')] # аналогично, создаю список, в который добавляю значение клетки, которые пользователь ввел
        # дополнительная проверка о правильности ввода игроком поля для игры в крестики нолики
        if len (row) != 3:
            print ("При вводе были нарушены правила ввода") # если пользователь ввел что-то не то, то выводится сообщение об ошибке
            return # завершает программу
        board.append(row) # добавляю строку в список board
    

    print ("--------------------------") # разделитель для удобства

    # функция для преобразования поля, с котором работает код, в поле, подчиненное стандарту (то есть имеющие квадратные скобки по бокам)
    def printBoard(board):  # передаю в функцию поле
        for row in board: # цикл для печати поля
            print('[' + ']['.join(row) + ']') # вывод поля в виде [X][0][ ]

    # функция для проверки на победу программы или пользователя
    def isWinner(board, player): # передаю в функцию поле и символ игрока
        for i in range(3): # цикл для проверки по строкам и столбцам
            if all(board[i][j] == player for j in range(3)): return True # если все клетки в строке или столбце равны символу игрока, то функция возвращает True
            if all(board[j][i] == player for j in range(3)): return True # аналогично
        if all(board[i][i] == player for i in range(3)): return True # проверка на диагонали
        if all(board[i][2 - i] == player for i in range(3)): return True # аналогично
        return False # если ни одно из условий не выполняется, то функция возвращает False
    
    # проверки на выигрышность позиций пользователя и прогаммы изначально
    if isWinner(board, '0'): # если пользователь выиграл
        print("Пользователь уже выиграл") # и пишет, что пользователь выиграл
        return # завершает программу
    if isWinner(board, 'X'): # если программа выиграла
        print("Бот уже выиграл") # и пишет, что бот выиграл
        return # завершает программу
    
    # функция для нахождения пустых клеток игрового поля
    def getEmptyKletki(board): # передаю в функцию поле
        return [(i, j) for i in range(3) for j in range(3) if board[i][j] == ' '] # возвращание списка из пустых клеток
    
    # создание списка пустых клеток, для того чтобы бот смог работать с ними дальше
    emptyKletki = getEmptyKletki(board) # присваивание переменной списка пустых клеток
    
    # дополнительная проверка на отсутствие пустых полей
    if not emptyKletki: 
        print ("Доска была заполнена. Возможных ходов нет") # если пустых клеток нет, то пишет, что ходов нет
        return # завершает программу
    
    # после всех пройденных проверок дальше и до конца находится код для выбора позиции ботом
    # далее под каждый блок кода будет свой комментарий с пояснениями
    # программа проходит через каждый блок кода и если в нем условие выполняется, то блок выпоняется
    # в первом и втором блоке кода бот иметируеn возможность хода, уже в комментах блоков расскажу подробнее
    
    # проверка на возможность выиграть партию сразу
    # бот проходит через все клетки и подставляет туда крестик
    # если же при какой-то позиции он выигралs, то печатает поле и завершает программу
    # если же нет, то очищает клетку, в которою подствавлял и идет дальше
    for i, j in emptyKletki: # проходит через все клетки
        board[i][j] = 'X' # ставит крестик в клетку
        if isWinner(board, 'X'): # проверяет, выиграл ли бот
            printBoard(board) # печатает поле
            print ("Бот смог сделать победный ход") # пишет, что бот смог сделать победный ход
            return # завершает программу
        board[i][j] = ' ' # очищает клетку
    
    # проверка на возможность закрыть ход соперника, для того чтобы хотя бы не проиграть сразу
    # программа аналогично прошлому блоку проходит через все клетки и подставляет туда нолик
    # если же при какой-то позиции пользователь выиграет, то на эту клетку ставит крестик и завершает программу
    # если же нет, то очищает клетку, в которою подствавлял и идет дальше
    for i, j in emptyKletki: # проходит через все клетки
        board[i][j] = '0' # ставит нолик в клетку
        if isWinner(board, '0'): # проверяет, выиграл ли пользователь
            board[i][j] = 'X' # поставляет крестик в клетку, которую бот должен закрыть
            printBoard(board) # печатает поле
            print ("Бот заблокировал выигрушную клетку соперника") # пишет, что бот смог заблокировать клетку соперника
            return # завершает программу
        board[i][j] = ' ' # очищает клетку
    
    # если же два предыдущих условия не выполняются, то бот делает ход в центр поля
    if (1, 1) in emptyKletki: # проверяет, есть ли центр поля в списке пустых клеток
        board[1][1] = 'X' # ставит крестик в центр поля
        printBoard(board) # печатает поле
        print ("Бот сделал ход в центр") # пишет, что бот сделал ход в центр
        return # завершает программу
    
    # если же центр занят, то бот делает ход в угол
    # здесь создается список угловых клеток, проверяется пустота этих клеток и выбирается случайная из не занятых, и туда бот делает ход
    corners = [(0, 0), (2, 0), (0, 2), (2, 2)] # список угловых клеток
    avialableCorners = [kletki for kletki in corners if kletki in emptyKletki] # список пустых угловых клеток
    if avialableCorners: # если список не пустой, то бот делает ход в угол
        i, j = random.choice(avialableCorners) # выбирает случайная из не занятых угловых клеток
        board[i][j] = 'X' # ставит крестик в эту клетку
        printBoard(board) # печатает поле
        print("Бот сделал ход в угол") # пишет, что бот сделал ход в угол
        return # завершает программу
    
    # если же все предыдущие условия не выполняются, то бот делает ход в любую свободную клетку
    i, j = random.choice(emptyKletki) # выбирается случайная из не занятых клеток
    board[i][j] = 'X' # ставит крестик в эту клетку
    printBoard(board) # печатает поле
    print("Бот сделал ход в любую свободную клетку") # пишет, что бот сделал ход в любую свободную клетку

# вызов функции бота
krestikiNoliki()